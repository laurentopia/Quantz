<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ETF NAV Trend Estimator</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .input-row { display: flex; align-items: center; gap: 10px; margin-bottom: 20px; flex-wrap: wrap; }
        .input-group { display: flex; align-items: center; gap: 10px; }
        input { padding: 10px; width: 200px; }
        button { padding: 10px 20px; background: #007bff; color: white; border: none; cursor: pointer; }
        button:hover { background: #0056b3; }
        #total { font-size: 1.2em; font-weight: bold; margin-left: 20px; padding: 10px; background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 4px; min-width: 300px; }
        #progress { font-size: 1.1em; margin: 10px 0; padding: 5px; background: #e9ecef; border-radius: 4px; text-align: center; }
        #loading { display: none; color: #007bff; }
        #status { margin-top: 10px; padding: 10px; background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 4px; max-height: 200px; overflow-y: auto; }
        #status p { margin: 5px 0; font-size: 0.9em; }
        table { border-collapse: collapse; width: 100%; margin-top: 10px; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
        .bullish { color: green; }
        .bearish { color: red; }
        .neutral { color: orange; }
        .error { color: red; }
        .success { color: green; }
        .info { color: #007bff; }
        #holdings-list { margin-top: 20px; padding: 10px; background: #f0f8ff; border: 1px solid #007bff; border-radius: 4px; }
        #retry-countdown { color: #007bff; font-weight: bold; }
        #disclaimer { margin-top: 20px; padding: 10px; background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 4px; }
    </style>
</head>
<body>
    <h1>ETF NAV Trend Estimator</h1>
    <div class="input-row">
        <div class="input-group">
            <p>Enter ETF symbol (e.g., SPY):</p>
            <input type="text" id="symbol" placeholder="SPY" value="ULTY">
            <button onclick="analyze()">Analyze</button>
        </div>
        <div id="total" style="display: none;"></div>
    </div>
    <div id="progress" style="display: none;">Neutral (0/0 sentiments)</div>
    <div id="holdings-list" style="display: none;"></div>
    <div id="loading">Loading...</div>
    <div id="status"></div>
    <table id="trends" style="display: none;">
        <thead>
            <tr>
                <th>Symbol</th>
                <th>Name</th>
                <th>Weight (%)</th>
                <th>Spot Price</th>
                <th>Weighted Strike</th>
                <th>Sentiment Ratio</th>
            </tr>
        </thead>
        <tbody></tbody>
    </table>
    <div id="disclaimer">if you find this tool useful, you can send me some coins: USDC BASE: 0xDcf2336c4bfe5742a061Fb27cf5dC4c1A322F4a5 ETH BASE:0xBC03c005B1B9F300738CC67fdD243c744c648023.</div>

    <script>
        const PROXIES = [
            'https://api.allorigins.win/raw?url=',
            'https://corsproxy.io/?',
            'https://api.codetabs.com/v1/proxy?quest='
        ];

        const CACHE_DURATION = 3600000;
        const MAX_RETRIES = 5;
        const RETRY_DELAY_BASE = 2000;

        function setCookie(name, value, days) {
            const expires = new Date(Date.now() + days * 864e5).toUTCString();
            document.cookie = `${name}=${encodeURIComponent(value)}; expires=${expires}; path=/; SameSite=Lax`;
        }

        function getCookie(name) {
            return document.cookie.split('; ').reduce((r, v) => {
                const parts = v.split('=');
                return parts[0] === name ? decodeURIComponent(parts[1]) : r;
            }, '');
        }

        function getSentimentCache(symbol) {
            const cached = getCookie(`sentiment_${symbol}`);
            if (!cached) return null;
            try {
                const { price, sentiment, weightedSentiment, timestamp } = JSON.parse(cached);
                if (Date.now() - timestamp < CACHE_DURATION) {
                    return { price, sentiment, weightedSentiment };
                }
            } catch (e) {
                console.log(`Invalid cache for ${symbol}: ${e.message}`);
            }
            return null;
        }

        function setSentimentCache(symbol, price, sentiment, weightedSentiment) {
            const cache = { price, sentiment, weightedSentiment, timestamp: Date.now() };
            setCookie(`sentiment_${symbol}`, JSON.stringify(cache), 30);
        }

        async function fetchViaProxy(url, maxRetries = MAX_RETRIES) {
            let lastError;
            for (let attempt = 0; attempt < maxRetries; attempt++) {
                const proxyIndex = attempt % PROXIES.length;
                const proxy = PROXIES[proxyIndex];
                const proxiedUrl = proxy + encodeURIComponent(url);
                console.log(`Attempt ${attempt + 1}/${maxRetries}: ${proxy.slice(0, 30)}...`);
                
                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 15000);
                    
                    const response = await fetch(proxiedUrl, { 
                        signal: controller.signal,
                        headers: { 'Accept': 'text/html,application/json,*/*' }
                    });
                    clearTimeout(timeoutId);
                    
                    if (response.ok) {
                        console.log(`Success with proxy ${proxyIndex + 1}`);
                        return response;
                    }
                    console.log(`Proxy ${proxyIndex + 1} returned status: ${response.status}`);
                    lastError = new Error(`Status ${response.status}`);
                } catch (e) {
                    console.log(`Proxy ${proxyIndex + 1} error: ${e.message}`);
                    lastError = e;
                }
                
                if (attempt < maxRetries - 1) {
                    const delay = RETRY_DELAY_BASE * Math.pow(1.5, attempt);
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
            throw new Error(`All ${maxRetries} proxy attempts failed: ${lastError?.message || 'Unknown error'}`);
        }

        function updateStatus(message, type = 'info') {
            const statusDiv = document.getElementById('status');
            const p = document.createElement('p');
            p.className = type;
            p.textContent = new Date().toLocaleTimeString() + ': ' + message;
            statusDiv.appendChild(p);
            statusDiv.scrollTop = statusDiv.scrollHeight;
            console.log(message);
        }

        function updateSummary(runningTotal, processed, total) {
            let interpretation = 'Neutral';
            let className = 'neutral';
            if (runningTotal > 0.01) {
                interpretation = 'Bullish';
                className = 'bullish';
            } else if (runningTotal < -0.01) {
                interpretation = 'Bearish';
                className = 'bearish';
            }
            document.getElementById('progress').innerHTML = `${interpretation} (${processed}/${total} sentiments)`;
            document.getElementById('progress').style.display = 'block';
            document.getElementById('total').innerHTML = `<span class="${className}">Total Weighted Sentiment: ${runningTotal.toFixed(4)} (${interpretation}) ${processed}/${total}</span><br>Estimated NAV direction based on options anticipation.`;
            document.getElementById('total').style.display = 'block';
        }

        async function getHoldings(etfSymbol) {
            updateStatus(`Fetching ETF holdings for ${etfSymbol}...`);
            const url = `https://stockanalysis.com/etf/${etfSymbol.toLowerCase()}/holdings/`;
            const proxyResponse = await fetchViaProxy(url);
            
            if (!proxyResponse.ok) {
                throw new Error(`Failed to fetch holdings: ${proxyResponse.status}`);
            }
            
            const text = await proxyResponse.text();
            const parser = new DOMParser();
            const doc = parser.parseFromString(text, 'text/html');
            
            const table = doc.querySelector('table');
            if (!table) throw new Error('No holdings table found');
            
            const rows = table.querySelectorAll('tbody tr');
            if (rows.length === 0) throw new Error('No holdings rows found');
            
            const holdings = [];
            rows.forEach(row => {
                const tds = row.querySelectorAll('td');
                if (tds.length >= 4) {
                    const symbolCell = tds[1].textContent.trim();
                    const nameCell = tds[2].textContent.trim();
                    const weightStr = tds[3].textContent.trim().replace('%', '');
                    const weight = parseFloat(weightStr);
                    
                    if (symbolCell && /^[A-Z]{1,5}$/.test(symbolCell) && !isNaN(weight) && weight > 0) {
                        holdings.push({ symbol: symbolCell, name: nameCell, percent: weight });
                    }
                }
            });
            
            updateStatus(`Parsed ${holdings.length} valid holdings`);
            return holdings;
        }

        async function getUnderlyingPrice(underlying) {
            updateStatus(`Fetching price for ${underlying}...`);
            const url = `https://query1.finance.yahoo.com/v8/finance/chart/${underlying}?range=1d&interval=1d`;
            const proxyResponse = await fetchViaProxy(url);
            
            if (!proxyResponse.ok) throw new Error(`Failed to fetch price: ${proxyResponse.status}`);
            
            const text = await proxyResponse.text();
            const data = JSON.parse(text);
            const meta = data.chart?.result?.[0]?.meta;
            
            if (!meta) throw new Error('No price data');
            
            const price = meta.regularMarketPrice ?? meta.previousClose ?? 0;
            if (price === 0) throw new Error('Invalid price');
            
            updateStatus(`Price for ${underlying}: $${price.toFixed(2)}`);
            return price;
        }

        async function getOptionChain(underlying) {
            updateStatus(`Fetching options for ${underlying}...`);
            const url = `https://finance.yahoo.com/quote/${underlying}/options/`;
            const proxyResponse = await fetchViaProxy(url);
            
            if (!proxyResponse.ok) throw new Error(`Failed to fetch options: ${proxyResponse.status}`);
            
            const text = await proxyResponse.text();
            const parser = new DOMParser();
            const doc = parser.parseFromString(text, 'text/html');
            
            const allTables = doc.querySelectorAll('table');
            const tables = Array.from(allTables).filter(t => {
                const ths = t.querySelectorAll('th');
                return Array.from(ths).some(th => th.textContent.includes('Strike') || th.textContent.includes('Open Interest'));
            });
            
            if (tables.length < 2) throw new Error('Options tables not found');
            
            const allOptions = [];
            tables.forEach(table => {
                const rows = table.querySelectorAll('tbody tr');
                rows.forEach(row => {
                    const tds = row.querySelectorAll('td');
                    if (tds.length >= 8) {
                        const strikeText = tds[2]?.textContent.trim().replace(/[^\d.]/g, '') || '';
                        const oiText = tds[tds.length - 1]?.textContent.trim().replace(/[^\d]/g, '') || '0';
                        const strike = parseFloat(strikeText);
                        const oi = parseInt(oiText) || 0;
                        
                        if (!isNaN(strike) && strike > 0 && oi > 0) {
                            allOptions.push({ strike, oi });
                        }
                    }
                });
            });
            
            if (allOptions.length === 0) throw new Error('No valid options found');
            
            updateStatus(`Parsed ${allOptions.length} options`);
            return allOptions;
        }

        function calculateSentiment(allOptions, underlyingPrice) {
            let totalOI = 0;
            let weightedStrike = 0;
            
            allOptions.forEach(opt => {
                totalOI += opt.oi;
                weightedStrike += opt.strike * opt.oi;
            });
            
            if (totalOI === 0) return 0;
            
            const avgStrike = weightedStrike / totalOI;
            let sentiment = (avgStrike - underlyingPrice) / underlyingPrice;
            sentiment = Math.max(-1, Math.min(1, sentiment));
            
            updateStatus(`Avg strike: $${avgStrike.toFixed(2)}, sentiment: ${sentiment.toFixed(4)}`);
            return sentiment;
        }

        async function processOneHolding(holding, forceRetry = false) {
            const underlying = holding.symbol;
            const weight = holding.percent;

            const cached = getSentimentCache(underlying);
            if (cached && !forceRetry) {
                updateStatus(`Using cache for ${underlying}`, 'info');
                return { price: cached.price, sentiment: cached.sentiment, weightedSentiment: cached.weightedSentiment };
            }

            try {
                const price = await getUnderlyingPrice(underlying);
                const allOptions = await getOptionChain(underlying);
                const sentiment = calculateSentiment(allOptions, price);
                const weightedSentiment = (weight / 100) * sentiment;
                
                setSentimentCache(underlying, price, sentiment, weightedSentiment);
                updateStatus(`${underlying}: sentiment ${sentiment.toFixed(4)}`, 'success');
                
                return { price, sentiment, weightedSentiment };
            } catch (e) {
                updateStatus(`Error ${underlying}: ${e.message}`, 'error');
                return { price: 0, sentiment: null, weightedSentiment: 0 };
            }
        }

        function updateRow(holding, price, sentiment, weightedSentiment) {
            const tbody = document.querySelector('#trends tbody');
            let row = Array.from(tbody.rows).find(r => r.cells[0].textContent.trim() === holding.symbol);
            
            let sentimentHtml;
            if (sentiment === null) {
                sentimentHtml = '<span class="error">failed</span>';
            } else {
                const cls = sentiment > 0 ? 'bullish' : sentiment < 0 ? 'bearish' : 'neutral';
                sentimentHtml = `<span class="${cls}">${sentiment.toFixed(4)} (${(weightedSentiment * 100).toFixed(2)}%)</span>`;
            }
            
            const rowHtml = `
                <tr>
                    <td>${holding.symbol}</td>
                    <td>${holding.name || 'N/A'}</td>
                    <td>${holding.percent.toFixed(2)}</td>
                    <td>$${price.toFixed(2)}</td>
                    <td>$${((price * (1 + (sentiment || 0))) || 0).toFixed(2)}</td>
                    <td>${sentimentHtml}</td>
                </tr>
            `;
            
            if (row) {
                row.outerHTML = rowHtml;
            } else {
                tbody.insertAdjacentHTML('beforeend', rowHtml);
            }
        }

        function calculateTotal(allHoldings) {
            return allHoldings.reduce((sum, h) => sum + (h.weightedSentiment || 0), 0);
        }

        async function analyze() {
            const symbol = document.getElementById('symbol').value.toUpperCase().trim();
            if (!symbol) return alert('Please enter a symbol');
            
            const loading = document.getElementById('loading');
            const table = document.getElementById('trends');
            const totalDiv = document.getElementById('total');
            const statusDiv = document.getElementById('status');
            const holdingsList = document.getElementById('holdings-list');
            const progressDiv = document.getElementById('progress');
            
            loading.style.display = 'block';
            table.style.display = 'none';
            totalDiv.style.display = 'none';
            holdingsList.style.display = 'none';
            progressDiv.style.display = 'none';
            statusDiv.innerHTML = '';
            table.querySelector('tbody').innerHTML = '';

            try {
                updateStatus(`Starting analysis for ${symbol}`, 'success');
                const allHoldings = await getHoldings(symbol);
                
                if (allHoldings.length === 0) {
                    totalDiv.innerHTML = '<span class="neutral">No valid holdings found</span>';
                    totalDiv.style.display = 'block';
                    return;
                }
                
                const holdingsHtml = allHoldings.map(h => `<p>${h.symbol} | ${h.name} | ${h.percent.toFixed(2)}%</p>`).join('');
                holdingsList.innerHTML = `<strong>Found ${allHoldings.length} Holdings:</strong><br>${holdingsHtml}`;
                holdingsList.style.display = 'block';
                
                table.style.display = 'table';
                updateSummary(0, 0, allHoldings.length);
                
                const results = await Promise.all(allHoldings.map(h => processOneHolding(h)));
                
                results.forEach((result, i) => {
                    allHoldings[i].price = result.price;
                    allHoldings[i].sentiment = result.sentiment;
                    allHoldings[i].weightedSentiment = result.weightedSentiment;
                    updateRow(allHoldings[i], result.price, result.sentiment, result.weightedSentiment);
                });
                
                let total = calculateTotal(allHoldings);
                let processed = allHoldings.filter(h => h.sentiment !== null && !isNaN(h.sentiment)).length;
                updateSummary(total, processed, allHoldings.length);
                
                const failed = allHoldings.filter(h => h.sentiment === null);
                if (failed.length > 0) {
                    updateStatus(`Retrying ${failed.length} failed holdings in 5s...`);
                    await new Promise(resolve => setTimeout(resolve, 5000));
                    
                    const retryResults = await Promise.all(failed.map(h => processOneHolding(h, true)));
                    
                    retryResults.forEach((result, i) => {
                        failed[i].price = result.price;
                        failed[i].sentiment = result.sentiment;
                        failed[i].weightedSentiment = result.weightedSentiment;
                        updateRow(failed[i], result.price, result.sentiment, result.weightedSentiment);
                    });
                    
                    total = calculateTotal(allHoldings);
                    processed = allHoldings.filter(h => h.sentiment !== null && !isNaN(h.sentiment)).length;
                    updateSummary(total, processed, allHoldings.length);
                }
                
                updateStatus('Analysis complete', 'success');
            } catch (error) {
                updateStatus(`Error: ${error.message}`, 'error');
                alert('Analysis failed: ' + error.message);
            }
            
            loading.style.display = 'none';
        }
    </script>
</body>
</html>
