<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ETF NAV Trend Estimator</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .input-row { display: flex; align-items: center; gap: 10px; margin-bottom: 20px; flex-wrap: wrap; }
        .input-group { display: flex; align-items: center; gap: 10px; }
        input { padding: 10px; width: 200px; }
        button { padding: 10px 20px; background: #007bff; color: white; border: none; cursor: pointer; }
        button:hover { background: #0056b3; }
        #total { font-size: 1.2em; font-weight: bold; margin-left: 20px; padding: 10px; background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 4px; min-width: 300px; }
        #progress { font-size: 1.1em; margin: 10px 0; padding: 5px; background: #e9ecef; border-radius: 4px; text-align: center; }
        #loading { display: none; color: #007bff; }
        #status { margin-top: 10px; padding: 10px; background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 4px; max-height: 200px; overflow-y: auto; }
        #status p { margin: 5px 0; font-size: 0.9em; }
        table { border-collapse: collapse; width: 100%; margin-top: 10px; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
        .bullish { color: green; }
        .bearish { color: red; }
        .neutral { color: orange; }
        .error { color: red; }
        .success { color: green; }
        .info { color: #007bff; }
        #holdings-list { margin-top: 20px; padding: 10px; background: #f0f8ff; border: 1px solid #007bff; border-radius: 4px; }
        #retry-countdown { color: #007bff; font-weight: bold; }
        #disclaimer { margin-top: 20px; padding: 10px; background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 4px; }
    </style>
</head>
<body>
    <h1>ETF NAV Trend Estimator</h1>
    <div class="input-row">
        <div class="input-group">
            <p>Enter ETF symbol (e.g., SPY):</p>
            <input type="text" id="symbol" placeholder="SPY" value="ULTY">
            <button onclick="analyze()">Analyze</button>
        </div>
        <div id="total" style="display: none;"></div>
    </div>
    <div id="progress" style="display: none;">Neutral (0/0 sentiments)</div>
    <div id="holdings-list" style="display: none;"></div>
    <div id="loading">Loading...</div>
    <div id="status"></div>
    <table id="trends" style="display: none;">
        <thead>
            <tr>
                <th>Symbol</th>
                <th>Name</th>
                <th>Weight (%)</th>
                <th>Spot Price</th>
                <th>Weighted Strike</th>
                <th>Sentiment Ratio</th>
            </tr>
        </thead>
        <tbody></tbody>
    </table>
    <div id="disclaimer">if you find this tool useful, you can send me some coins: USDC BASE: 0xDcf2336c4bfe5742a061Fb27cf5dC4c1A322F4a5 ETH BASE:0xBC03c005B1B9F300738CC67fdD243c744c648023.</div>

    <script>
        const PROXIES = [
            'https://corsproxy.io/?',
            'https://api.allorigins.win/raw?url=',
            'https://thingproxy.freeboard.io/fetch/',
            'https://proxy.cors.sh/?'
        ];

        const CACHE_DURATION = 3600000; // 1 hour in ms

        function setCookie(name, value, days) {
            const expires = new Date(Date.now() + days * 864e5).toUTCString();
            document.cookie = `${name}=${value}; expires=${expires}; path=/`;
        }

        function getCookie(name) {
            return document.cookie.split('; ').reduce((r, v) => {
                const parts = v.split('=');
                return parts[0] === name ? decodeURIComponent(parts[1]) : r;
            }, '');
        }

        function getSentimentCache(symbol) {
            const cached = getCookie(`sentiment_${symbol}`);
            if (!cached) return null;
            try {
                const { price, sentiment, weightedSentiment, timestamp } = JSON.parse(cached);
                if (Date.now() - timestamp < CACHE_DURATION) {
                    return { price, sentiment, weightedSentiment };
                }
            } catch (e) {
                console.log(`Invalid cache for ${symbol}: ${e.message}`);
            }
            return null;
        }

        function setSentimentCache(symbol, price, sentiment, weightedSentiment) {
            const cache = {
                price,
                sentiment,
                weightedSentiment,
                timestamp: Date.now()
            };
            setCookie(`sentiment_${symbol}`, JSON.stringify(cache), 30);
        }

        async function fetchViaProxy(url, maxRetries = 4) {
            for (let attempt = 0; attempt < maxRetries; attempt++) {
                const proxy = PROXIES[attempt % PROXIES.length];
                const proxiedUrl = proxy + encodeURIComponent(url);
                console.log(`Attempt ${attempt + 1}: Fetching via proxy: ${proxiedUrl}`);
                try {
                    const response = await fetch(proxiedUrl);
                    if (response.ok) {
                        return response;
                    }
                    console.log(`Proxy failed with status: ${response.status}`);
                } catch (e) {
                    console.log(`Proxy error: ${e.message}`);
                }
                await delay(1000 * (attempt + 1));
            }
            throw new Error(`All proxies failed for ${url}`);
        }

        function updateStatus(message, type = 'info') {
            const statusDiv = document.getElementById('status');
            const p = document.createElement('p');
            p.className = type;
            p.textContent = new Date().toLocaleTimeString() + ': ' + message;
            statusDiv.appendChild(p);
            statusDiv.scrollTop = statusDiv.scrollHeight;
            console.log(message);
        }

        function updateSummary(runningTotal, processed, total) {
            let interpretation = 'Neutral';
            let className = 'neutral';
            if (runningTotal > 0.01) {
                interpretation = 'Bullish';
                className = 'bullish';
            } else if (runningTotal < -0.01) {
                interpretation = 'Bearish';
                className = 'bearish';
            }
            document.getElementById('progress').innerHTML = `${interpretation} (${processed}/${total} sentiments)`;
            document.getElementById('progress').style.display = 'block';
            document.getElementById('total').innerHTML = `<span class="${className}">Total Weighted Sentiment: ${runningTotal.toFixed(4)} (${interpretation}) ${processed}/${total}</span><br>Estimated NAV direction based on options anticipation.`;
            document.getElementById('total').style.display = 'block';
        }

        async function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        async function getHoldings(etfSymbol) {
            updateStatus(`Fetching ETF holdings for ${etfSymbol} from stockanalysis.com via proxy...`);
            const url = `https://stockanalysis.com/etf/${etfSymbol.toLowerCase()}/holdings/`;
            const proxyResponse = await fetchViaProxy(url);
            updateStatus(`Proxy response status: ${proxyResponse.status}`);
            if (!proxyResponse.ok) {
                throw new Error(`Failed to fetch holdings page: ${proxyResponse.status} ${proxyResponse.statusText}`);
            }
            const text = await proxyResponse.text();
            updateStatus('Parsing holdings HTML...');
            let doc;
            try {
                const parser = new DOMParser();
                doc = parser.parseFromString(text, 'text/html');
            } catch (e) {
                throw new Error(`Failed to parse HTML: ${e.message}`);
            }
            const table = doc.querySelector('table');
            if (!table) {
                throw new Error('No holdings table found on page');
            }
            const rows = table.querySelectorAll('tr');
            if (rows.length < 2) {
                throw new Error('No holdings rows found');
            }
            const holdings = [];
            for (let i = 1; i < rows.length; i++) {
                const tds = rows[i].querySelectorAll('td');
                if (tds.length >= 4) {
                    const symbolCell = tds[1].textContent.trim();
                    const nameCell = tds[2].textContent.trim();
                    const weightStr = tds[3].textContent.trim().replace('%', '');
                    const weight = parseFloat(weightStr);
                    if (symbolCell && /^[A-Z]{2,5}$/.test(symbolCell) && !isNaN(weight) && weight > 0) {
                        holdings.push({
                            symbol: symbolCell,
                            name: nameCell,
                            percent: weight
                        });
                    }
                }
            }
            updateStatus(`Successfully parsed ${holdings.length} valid stock holdings.`);
            return holdings;
        }

        async function getUnderlyingPrice(underlying) {
            updateStatus(`Fetching spot price for ${underlying} from Yahoo chart API via proxy...`);
            const url = `https://query1.finance.yahoo.com/v8/finance/chart/${underlying}?range=1d`;
            const proxyResponse = await fetchViaProxy(url);
            updateStatus(`Yahoo chart proxy response status: ${proxyResponse.status}`);
            if (!proxyResponse.ok) {
                throw new Error(`Failed to fetch price: ${proxyResponse.status} ${proxyResponse.statusText}`);
            }
            const text = await proxyResponse.text();
            let data;
            try {
                data = JSON.parse(text);
            } catch (e) {
                throw new Error(`Failed to parse price JSON: ${e.message}`);
            }
            const meta = data.chart?.result?.[0]?.meta;
            if (!meta) {
                throw new Error('No meta data returned');
            }
            const price = meta.regularMarketPrice || meta.previousClose || 0;
            if (price === 0) {
                throw new Error('No valid price returned');
            }
            updateStatus(`Spot price for ${underlying}: $${price.toFixed(2)}`);
            return price;
        }

        async function getOptionChain(underlying) {
            updateStatus(`Fetching options page for ${underlying} from Yahoo via proxy...`);
            const url = `https://finance.yahoo.com/quote/${underlying}/options/`;
            const proxyResponse = await fetchViaProxy(url);
            updateStatus(`Yahoo options proxy response status: ${proxyResponse.status}`);
            if (!proxyResponse.ok) {
                throw new Error(`Failed to fetch options page: ${proxyResponse.status} ${proxyResponse.statusText}`);
            }
            const text = await proxyResponse.text();
            updateStatus('Parsing options HTML...');
            let doc;
            try {
                const parser = new DOMParser();
                doc = parser.parseFromString(text, 'text/html');
            } catch (e) {
                throw new Error(`Failed to parse options HTML: ${e.message}`);
            }
            let callsTable = doc.querySelector('table.calls');
            let putsTable = doc.querySelector('table.puts');
            if (!callsTable || !putsTable) {
                const allTables = doc.querySelectorAll('table');
                let callFound = false;
                for (const table of allTables) {
                    const ths = table.querySelectorAll('th');
                    if (ths.length > 0 && Array.from(ths).some(th => th.textContent.includes('Open Int'))) {
                        if (!callFound) {
                            callsTable = table;
                            callFound = true;
                        } else {
                            putsTable = table;
                            break;
                        }
                    }
                }
            }
            if (!callsTable || !putsTable) throw new Error('No options tables found');
            const allOptions = [];
            const callsRows = callsTable.querySelectorAll('tbody tr');
            callsRows.forEach(row => {
                const tds = row.querySelectorAll('td');
                if (tds.length >= 10) {
                    const strikeText = tds[2].textContent.trim().replace(/[^\d.]/g, '');
                    const oiText = tds[9].textContent.trim().replace(/[^\d]/g, '');
                    const strike = parseFloat(strikeText);
                    const oi = parseInt(oiText) || 0;
                    if (!isNaN(strike) && oi > 0) {
                        allOptions.push({strike, oi});
                    }
                }
            });
            const putsRows = putsTable.querySelectorAll('tbody tr');
            putsRows.forEach(row => {
                const tds = row.querySelectorAll('td');
                if (tds.length >= 10) {
                    const strikeText = tds[2].textContent.trim().replace(/[^\d.]/g, '');
                    const oiText = tds[9].textContent.trim().replace(/[^\d]/g, '');
                    const strike = parseFloat(strikeText);
                    const oi = parseInt(oiText) || 0;
                    if (!isNaN(strike) && oi > 0) {
                        allOptions.push({strike, oi});
                    }
                }
            });
            if (allOptions.length === 0) throw new Error('No options with open interest found');
            updateStatus(`Successfully parsed ${allOptions.length} options with open interest.`);
            return allOptions;
        }

        function calculateSentiment(allOptions, underlyingPrice) {
            updateStatus(`Calculating sentiment for underlying price $${underlyingPrice.toFixed(2)}...`);
            let totalOI = 0;
            let weightedStrike = 0;
            allOptions.forEach(opt => {
                totalOI += opt.oi;
                weightedStrike += opt.strike * opt.oi;
            });
            updateStatus(`Processed ${allOptions.length} options, total OI: ${totalOI}`);
            if (totalOI === 0) {
                updateStatus('No open interest found, sentiment = 0');
                return 0;
            }
            const avgStrike = weightedStrike / totalOI;
            let sentiment = (avgStrike - underlyingPrice) / underlyingPrice;
            sentiment = Math.max(-1, Math.min(1, sentiment));
            updateStatus(`Average strike: $${avgStrike.toFixed(2)}, raw sentiment: ${sentiment.toFixed(4)}`);
            return sentiment;
        }

        async function processOneHolding(holding, forceRetry = false) {
            const underlying = holding.symbol;
            const weight = holding.percent;
            let price = holding.price || 0;
            let sentiment = holding.sentiment || 0;
            let weightedSentiment = holding.weightedSentiment || 0;

            const cached = getSentimentCache(underlying);
            if (cached && !forceRetry) {
                updateStatus(`Using cached sentiment for ${underlying} (fresh within 1 hour)`, 'info');
                return {
                    price: cached.price,
                    sentiment: cached.sentiment,
                    weightedSentiment: cached.weightedSentiment
                };
            }

            try {
                price = await getUnderlyingPrice(underlying);
                const allOptions = await getOptionChain(underlying);
                sentiment = calculateSentiment(allOptions, price);
                weightedSentiment = (weight / 100) * sentiment;
                setSentimentCache(underlying, price, sentiment, weightedSentiment);
                updateStatus(`Computed ${underlying}: sentiment ${sentiment.toFixed(4)}, weighted ${weightedSentiment.toFixed(4)} (cached for 1 hour)`, 'success');
            } catch (e) {
                if (e.message.includes('All proxies failed')) {
                    sentiment = null;
                    updateStatus(`Proxy failure for ${underlying}: compute failed (ignored in counter)`, 'error');
                } else {
                    sentiment = 0;
                    updateStatus(`Error processing ${underlying}: ${e.message} (sentiment = ${sentiment.toFixed(4)})`, 'error');
                }
            }
            return { price, sentiment, weightedSentiment };
        }

        function updateRow(holding, price, sentiment, weightedSentiment) {
            const tbody = document.querySelector('#trends tbody');
            let row = Array.from(tbody.rows).find(r => r.cells[0].textContent.trim() === holding.symbol);
            let sentimentHtml;
            if (sentiment === null) {
                sentimentHtml = '<span class="error">compute failed</span> (0.00% weighted)';
            } else {
                sentimentHtml = `<span class="${sentiment > 0 ? 'bullish' : sentiment < 0 ? 'bearish' : 'neutral'}">${sentiment.toFixed(4)} (${(weightedSentiment * 100).toFixed(2)}% weighted)</span>`;
            }
            const rowHtml = `
                <tr>
                    <td>${holding.symbol}</td>
                    <td>${holding.name || 'N/A'}</td>
                    <td>${holding.percent.toFixed(2)}</td>
                    <td>$${price.toFixed(2)}</td>
                    <td>$${((price * (1 + (sentiment || 0))) || 0).toFixed(2)}</td>
                    <td>${sentimentHtml}</td>
                </tr>
            `;
            if (row) {
                row.outerHTML = rowHtml;
            } else {
                tbody.insertAdjacentHTML('beforeend', rowHtml);
            }
        }

        function calculateTotal(allHoldings) {
            return allHoldings.reduce((sum, h) => sum + (h.weightedSentiment || 0), 0);
        }

        async function analyze() {
            const symbol = document.getElementById('symbol').value.toUpperCase().trim();
            if (!symbol) return alert('Please enter a symbol');
            const loading = document.getElementById('loading');
            const table = document.getElementById('trends');
            const totalDiv = document.getElementById('total');
            const statusDiv = document.getElementById('status');
            const holdingsList = document.getElementById('holdings-list');
            const progressDiv = document.getElementById('progress');
            loading.style.display = 'block';
            table.style.display = 'none';
            totalDiv.style.display = 'none';
            holdingsList.style.display = 'none';
            progressDiv.style.display = 'none';
            statusDiv.innerHTML = '';
            const tbody = table.querySelector('tbody');
            tbody.innerHTML = '';

            try {
                updateStatus(`Starting analysis for ETF: ${symbol}`, 'success');
                let allHoldings = await getHoldings(symbol);
                const totalHoldings = allHoldings.length;
                if (totalHoldings === 0) {
                    totalDiv.innerHTML = '<span class="neutral">Total Weighted Sentiment: --no holdings-- (No valid stock holdings found)</span>';
                    totalDiv.style.display = 'block';
                    updateStatus('No valid holdings found.', 'error');
                    return;
                }
                updateStatus(`Processing ${totalHoldings} valid holdings in parallel (using cache if fresh)...`);

                // Display found holdings for verification
                const holdingsHtml = allHoldings.map(h => `<p>${h.symbol} | ${h.name} | ${h.percent.toFixed(2)}%</p>`).join('');
                holdingsList.innerHTML = `<strong>Found Holdings:</strong><br>${holdingsHtml}`;
                holdingsList.style.display = 'block';

                table.style.display = 'table';
                updateSummary(0, 0, totalHoldings);

                // Parallel initial processing
                const promises = allHoldings.map(holding => processOneHolding(holding));
                const results = await Promise.all(promises);
                results.forEach((result, index) => {
                    const holding = allHoldings[index];
                    holding.price = result.price;
                    holding.sentiment = result.sentiment;
                    holding.weightedSentiment = result.weightedSentiment;
                    updateRow(holding, result.price, result.sentiment, result.weightedSentiment);
                });
                const runningTotal = calculateTotal(allHoldings);
                const processed = allHoldings.filter(h => h.sentiment !== undefined && h.sentiment !== null && !isNaN(h.sentiment)).length;
                updateSummary(runningTotal, processed, totalHoldings);

                const failedHoldings = allHoldings.filter(h => h.sentiment === null || h.price === 0);
                if (failedHoldings.length > 0) {
                    updateStatus(`Initial processing complete. ${failedHoldings.length} failed. Starting 10s countdown for retry...`);
                    for (let i = 10; i > 0; i--) {
                        const countdownDiv = document.createElement('div');
                        countdownDiv.id = 'retry-countdown';
                        countdownDiv.textContent = `Retry in ${i}s...`;
                        countdownDiv.className = 'info';
                        statusDiv.appendChild(countdownDiv);
                        await delay(1000);
                        if (statusDiv.contains(countdownDiv)) {
                            statusDiv.removeChild(countdownDiv);
                        }
                    }
                    updateStatus('Retrying failed holdings in parallel...');
                    const retryPromises = failedHoldings.map(holding => processOneHolding(holding, true));
                    const retryResults = await Promise.all(retryPromises);
                    retryResults.forEach((result, index) => {
                        const holding = failedHoldings[index];
                        holding.price = result.price;
                        holding.sentiment = result.sentiment;
                        holding.weightedSentiment = result.weightedSentiment;
                        updateRow(holding, result.price, result.sentiment, result.weightedSentiment);
                    });
                    const finalTotal = calculateTotal(allHoldings);
                    const finalProcessed = allHoldings.filter(h => h.sentiment !== undefined && h.sentiment !== null && !isNaN(h.sentiment)).length;
                    updateSummary(finalTotal, finalProcessed, totalHoldings);
                    updateStatus(`Retry complete.`, 'success');
                }

                updateStatus(`All processing complete.`, 'success');
            } catch (error) {
                updateStatus(`Overall error: ${error.message}`, 'error');
                alert('Error during analysis: ' + error.message);
            }
            loading.style.display = 'none';
        }
    </script>
</body>
</html>